const path = require('path');
const Trackable = require('../../Utilities/Trackable');
const virtualModulePluginPath = require.resolve(
    '../plugins/VirtualModulesPlugin'
);

let ids = 0;

/**
 * A module that can be changed by a third party.
 *
 * When Webpack loads a module into its bundles, it processes the source code
 * through a set of rules generated by Buildpack. A PublicModule is a reference
 * to that source file, meant to be passed to interceptors. Inside
 * interceptors, extensions and projects can configure the PublicModule to
 * transform in many ways.
 */
class TargetableModule extends Trackable {
    constructor(file, trackingOwner) {
        super();
        this.file = file;
        this._queuedTransforms = [];
        this.attach(this.file, trackingOwner);
    }
    _addVirtualFile(contents) {
        const extension = path.extname(this.file);
        const virtualFilePath = path.join(
            path.dirname(this.file),
            `${path.basename(
                this.file,
                extension
            )}__VIRTUAL__${ids++}${extension}`
        );
        const request = {
            type: 'plugin',
            fileToTransform: this.file,
            transformModule: virtualModulePluginPath,
            options: { contents, virtualFilePath }
        };
        this._queuedTransforms.push(request);
        this.track('addVirtualFile', { from: this.file, to: virtualFilePath });
        return virtualFilePath;
    }
    _normalizeOptionalFirstArg(arg1, arg2, defaultFirstArg) {
        return arg2 === undefined
            ? [defaultFirstArg, arg1]
            : [arg1 || defaultFirstArg, arg2];
    }
    addTransform(type, transformModule, options) {
        const request = {
            type,
            fileToTransform: this.file,
            transformModule,
            options
        };
        this._queuedTransforms.push(request);
        this.track('addTransform', request);
        return this;
    }
    flush() {
        return this._queuedTransforms.splice(0, this._queuedTransforms.length);
    }
    /**
     * Replace this module with the source code provided.
     *
     * All transforms registered so far on this module are canceled.
     * The new module has no access to the old module, unlike with `.wrap`.
     *
     * @param {string} newSource Source text of the new module, as a string.
     */
    replace(source) {
        this.reset();
        const virtualSourcePath = this._addVirtualFile(source.toString());
        return this.addTransform('replace', virtualSourcePath);
    }
    /**
     * Replace this module with another module.
     *
     * All transforms registered so far on this module are canceled.
     * The new module has no access to the old module, unlike wrappers.
     *
     * @param {string} replacementModule Import path to the replacement module. Should be package-absolute.
     */
    replaceWithFile(replacementModule) {
        return this.reset().addTransform('replace', replacementModule);
    }
    /**
     * Cancel all transforms registered so far on this module.
     */
    reset() {
        const cancelled = this.flush();
        this.track('reset', { count: cancelled.length, cancelled });
        return this;
    }
}

module.exports = TargetableModule;
